<!DOCTYPE html>


<html>
<head>
  <title>Documentation for gololang.Async</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: Helvetica, Arial, sans-serif;
      color: #333;
      background-color: #fff;
      border-color: #999999;
      border-width: 2px;
      line-height: 1.5;
      margin: 2em 3em;
      text-align: left;
      padding: 0 100px 0 100px;
    }
    pre {
      background-color: #eee;
      padding: 10px;
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      border-radius: 5px;
      overflow: auto;
    }
    code {
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 80%;
      background-color: #eee;
      padding: 1px 3px;
      -webkit-border-radius: 2px;
      -moz-border-radius: 2px;
      border-radius: 2px;
    }
    pre code {
      padding-left: 0px;
      padding-right: 0px;
    }
    li p {
      margin: 0.3em;
    }
    ul > li {
      list-style-type: disc;
    }
    a:link, a:visited {
      color: #33e;
      text-decoration: none;
    }
    a:hover {
      color: #00f;
      text-decoration:underline;
    }
    h1 {
      color: #999;
      font-weight: 400;
      font-size: 36px;
    }
    h2 {
      border-bottom: 1px dotted #aaa;
      margin-bottom: 1em;
      color: #333;
      font-size: 30px;
    }
    h3 {
      color: #666;
      font-size: 24px;
    }
    h4 {
      font-size: 21px;
    }
    h5 {
      font-size: 18px;
    }
  </style>
</head>
<body>

<h1>Documentation for gololang.Async</h1>
<div>
  <p>This module offers asynchronous programming helpers, especially execution context agnostic promises
and futures. The provided APIs are orthogonal to the execution strategy: it is up to you to execute
code from the same thread, from a separate thread, or by pushing new tasks to a service executor.</p>
<p>The functions and augmentations in this module often delegate to Java classes from
<code>gololang.concurrent.async</code>.</p>

</div>


<h2>Functions</h2>

  <h3>all(futures)</h3>
  <div>
    <p>Given a collection of futures, returns a future whose value is eventually avector with the
results of these futures.</p>
<p>Given:</p>
<pre><code>all([ setFuture(1), failedFuture(e) ])
</code></pre>
<p>this yields a future whose eventual value is:</p>
<pre><code>vector[1, e]
</code></pre>
<p>Results are accumulated as futures get resolved. The last completed future triggers the calls to
<code>onSet</code>-registered listeners on the same thread.</p>

  </div>

  <h3>any(futures)</h3>
  <div>
    <p>Given a collection of futures, returns a future whose value is set to the first completing future.</p>
<p>If all futures fail, then the returned future fails to a <code>java.util.NoSuchElementException</code>.</p>

  </div>

  <h3>failedFuture(throwable)</h3>
  <div>
    <p>Returns a failed future to a <code>throwable</code> exception.</p>

  </div>

  <h3>promise()</h3>
  <div>
    <p>Returns a new promise. Promise objects have the following useful methods.</p>
<ul>
<li><code>set(value)</code>: sets the promise value. The value is ignored if the promise has already been set.</li>
<li><code>fail(exception)</code>: set the value to an exception.</li>
<li><code>get()</code>: returns the promise value. It returns a bogus <code>null</code> value if the promise is still
undefined.</li>
<li><code>blockingGet()</code>: waits until the promise is set or failed, and returns the value.</li>
<li><code>future()</code>: returns a new future object on a promise.</li>
<li><code>isResolved()</code> and <code>isFailed()</code> query the promise status.</li>
</ul>
<p>Future objects have the following methods.</p>
<ul>
<li><code>onSet(|v| {...})</code>: registers a callback when the value is set, or executes it right now if it
has already been set.</li>
<li><code>onFail(|e| {...})</code>: registers a callback when the corresponding promise fails with an exception.</li>
<li><code>isResolved()</code>, <code>isFailed()</code> <code>get()</code> and <code>blockingGet()</code> delegate to the promise implementation.</li>
</ul>

  </div>

  <h3>reduce(futures, init, reducer)</h3>
  <div>
    <p>Returns a future whose value is set to the <em>reduction</em> of a collection of futures.</p>
<ul>
<li><code>futures</code> is a collection of futures, and</li>
<li><code>init</code> is the initial value, and</li>
<li><code>reducer</code> is the reducing function of the form <code>|acc, next| {...}</code>.</li>
</ul>
<p>If any future fails, then the result future fails, too. Otherwise, the returned future is set to the
accumulation of the values. Listeners callbacks get executed on the thread of the completing future
which is either the last successful future or the first future to fail.</p>

  </div>

  <h3>setFuture(value)</h3>
  <div>
    <p>Returns a future set to <code>value</code>.</p>

  </div>




<h2>Augmentations</h2>

  <h3>gololang.Async.types.FutureBridge</h3>
  <div>
    <p>A set of forwarding augmentations for <code>FutureBridge</code> instances.</p>
<p>The provided functions all forward to Golo futures, while <code>cancel</code> forwards to a Java future.</p>

  </div>
  
    
      <h4>cancel(this, mayInterruptIfRunning)</h4>
    
    <div>
      
    </div>
  
    
      <h4>fallbackTo(this, future)</h4>
    
    <div>
      
    </div>
  
    
      <h4>filter(this, pred)</h4>
    
    <div>
      
    </div>
  
    
      <h4>flatMap(this, fun)</h4>
    
    <div>
      
    </div>
  
    
      <h4>map(this, fun)</h4>
    
    <div>
      
    </div>
  
    
      <h4>onFail(this, listener)</h4>
    
    <div>
      
    </div>
  
    
      <h4>onSet(this, listener)</h4>
    
    <div>
      
    </div>
  

  <h3>gololang.concurrent.async.Future</h3>
  <div>
    <p>Augementation on the base <code>Future</code> objects provided by the <code>gololang.concurrent.async.Future</code> Java
class.</p>

  </div>
  
    
      <h4>fallbackTo(this, future)</h4>
    
    <div>
      <p>Returns a fallback future:</p>
<ul>
<li>when this future is set, the returned future is set to the same value,</li>
<li>when it fails, the returned future matches the success or failure of <code>future</code>.</li>
</ul>

    </div>
  
    
      <h4>filter(this, pred)</h4>
    
    <div>
      <p>Returns a future that filters this future through the <code>pred</code> predicate function.</p>
<p>Suppose that this future is set to <code>v</code>:</p>
<ul>
<li>if <code>pred(v)</code> is <code>true</code>, then the result future is set to <code>v</code>,</li>
<li>if <code>pred(v)</code> is <code>false</code>, then the result is failed to a <code>java.util.NoSuchElementException</code>.</li>
</ul>
<p>If this future fails, so does the returned future.</p>

    </div>
  
    
      <h4>flatMap(this, fun)</h4>
    
    <div>
      <p>Similar to <code>map</code>, except that <code>fun</code> returns a future, not a value.</p>

    </div>
  
    
      <h4>map(this, fun)</h4>
    
    <div>
      <p>Returns a future whose value is mapped through the <code>fun</code> function.</p>
<p>If this future is set to <code>v</code>, then the returned future is set to <code>fun(v)</code>. If it fails, the
returned future is also failed with the same exception.</p>

    </div>
  

  <h3>java.util.concurrent.ExecutorService</h3>
  <div>
    <p>Augmentations for <code>ExecutorService</code>.</p>

  </div>
  
    
      <h4>enqueue(this, fun)</h4>
    
    <div>
      <p>Submits a function <code>fun</code> to be executed by this scheduler, and returns a <code>FutureBridge</code>.</p>
<p><code>fun</code> takes no parameters, and its return value is used as a future value.</p>
<p>The returned <code>FutureBridge</code> behaves both as a composable Golo future and as a Java future that can be
cancelled.</p>
<p>Here is a sample usage:</p>
<pre><code># Enqueue some elaborated work
let f = executor: enqueue({
  Thread.sleep(1000_L)
  return 666
})

# Watch what could happen
f: onSet(|v| -&gt; println(v)): 
   onFail(|e| -&gt; println(e: getMessage()))

# ...but make it fail unless the CPU was too slow
f: cancel(true)
</code></pre>

    </div>
  




<h2>Structs</h2>

  <h3>FutureBridge</h3>
  <p>Members:</p>
  <ul>
  
    <li><code>_goloFuture</code></li>
  
    <li><code>_javaFuture</code></li>
  
  </ul>
  <div>
    <p>Bridge structure to hold a reference to a Golo future and a Java future.</p>
<p>Instances of this struct are being returned by the <code>enqueue</code> augmentation on <code>ExecutorService</code>
instances. This essentially adds the ability to:</p>
<ul>
<li>use the Golo future for its composability, and</li>
<li>use tha Java future to cancel a job.</li>
</ul>

  </div>



</body>
</html>
